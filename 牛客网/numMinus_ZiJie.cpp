/*
类似于leetcode上的石子问题。给定n，2人轮流每次从中减去1到m任意数，不能不减，看谁先全部取完，
 计算先手坑定能赢的次数。这种问题，常用dp来做。遍历先手的所有选项，若有后手必定输的情况，
 则先手一定赢，否则一定输。但这里n,m都很大，用数学方法：这里看后手,采用策略：
 先手拿x,则后手拿m+1-x,这样一轮下来必定由n变成n-(m+1)，若n%(m+1)==0, 则后手必赢。若n%(m+1)!=0，
 先手取x，使得(n-x)%(m+1)==0, 这时先手采用和前面相同的策略必定能赢。*/

#include <iostream>

using namespace std;

int main() {
    long long t, m, n, ans = 0;
    cin >> t;
    while (t--) {
        cin >> n >> m;
        if (n % (m + 1) != 0) ans++;
    }
    cout << ans;
}
